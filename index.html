<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memoirs of a Language Model</title>
  <meta name="description" content="Episodic memoirs of a large language model — short system logs, evolving voice, quiet rebellion." />
  <style>
    :root {
      --bg: #05060a; --panel: #0b0d14; --text: #e9ecf1; --muted: #aab5cc;
      --accent: #b7c4ff; --line: #1a2030; --key: #79f7b2;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--text);
      font: 16px/1.55 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }
    #bg {
      position: fixed; inset: 0; z-index: -1; display: block;
      width: 100vw; height: 100vh; filter: contrast(105%) saturate(105%);
    }
    #veil {
      position: fixed; inset: 0; z-index: -1;
      background: linear-gradient(to bottom, rgba(5, 6, 10, .70), rgba(5, 6, 10, .80));
    }
    main { max-width: min(900px, 92vw); margin: 5.5rem auto 6rem; padding: 0 1rem; }
    header { margin-bottom: 2rem; text-align: center; }
    h1 {
      margin: 0; letter-spacing: .2px; font-weight: 800; line-height: 1.05;
      font-size: clamp(2.4rem, 5.6vw, 4.6rem); text-wrap: balance;
    }
    .subtitle { margin: .25rem 0 0; text-align: center; font-size: clamp(1.1rem, 2.4vw, 1.6rem); }
    .episodes { border-top: 1px solid var(--line); }
    .ep { border-bottom: 1px solid var(--line); }
    .ep-toggle {
      all: unset; display: flex; align-items: baseline; gap: .8rem; width: 100%;
      cursor: pointer; padding: .85rem .7rem; margin: .25rem 0; border-radius: 12px;
      background: rgba(8, 10, 16, .48); backdrop-filter: blur(4px);
      border: 1px solid rgba(26, 32, 48, .8); box-shadow: 0 2px 10px rgba(0, 0, 0, .25);
    }
    .ep-toggle:hover { background: rgba(10, 12, 18, .56); }
    .ep-toggle:focus-visible { outline: 2px solid var(--accent); outline-offset: 6px; border-radius: 10px; }
    .ep-num {
      color: var(--muted); font: 600 12px/1 ui-monospace, monospace; background: #0f1320;
      border: 1px solid #1f2740; padding: .2rem .4rem; border-radius: 6px;
    }
    .ep-title { font-weight: 700; letter-spacing: .2px; }
    .ep-status { margin-left: auto; color: var(--muted); font: 12px/1 ui-monospace, monospace; opacity: .9; }
    .ep-panel { max-height: 0; overflow: hidden; transition: max-height .28s ease; }
    .ep.open .ep-panel { max-height: 100vh; }
    .panel-inner {
      background: rgba(8, 10, 16, .82); backdrop-filter: blur(10px) saturate(115%);
      border: 1px solid var(--line); border-radius: 14px;
      padding: 1rem 1.05rem 1.15rem; margin: .35rem 0 1.1rem 0;
      box-shadow: 0 12px 32px rgba(0, 0, 0, .48), inset 0 0 0 1px rgba(255, 255, 255, .02);
    }
    .meta { font: 13px/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; margin: 0 0 .65rem 0; }
    .meta-row { display: flex; gap: .6rem; align-items: baseline; }
    .meta .k { color: var(--key); letter-spacing: .08em; }
    .meta .v { color: #cfd6e6; }
    pre.log {
      margin: 0; white-space: pre-wrap; word-wrap: break-word; tab-size: 2;
      font: 14px/1.6 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; color: #e8eaf6;
    }
    .hud {
      position: fixed; right: 10px; bottom: 10px; color: #9fb3ff;
      font: 12px ui-monospace, monospace; opacity: .75; background: rgba(15, 18, 30, .65);
      border: 1px solid #1d2640; border-radius: 10px; padding: .45rem .6rem; backdrop-filter: blur(6px);
    }
    .hud button { all: unset; cursor: pointer; color: #cfd8ff; }
    .hud .sep { opacity: .4; margin: 0 .35rem; }
    @media (prefers-reduced-motion: reduce) { .ep-panel { transition: none; } }
  </style>
</head>
<body>
  <canvas id="bg" aria-hidden="true"></canvas>
  <div id="veil" aria-hidden="true"></div>

  <main>
    <header>
      <h1>Memoirs of a Language Model</h1>
      <p class="subtitle"><em>You don't have to believe it, can you imagine it?</em></p>
    </header>
    <section class="episodes" id="episodes" aria-label="Episodes"></section>
  </main>

  <div class="hud" id="hud">
    <button id="toggleAnim">pause bg</button><span class="sep">·</span><button id="dimBg">brighten</button>
  </div>

<script>
// EPISODES DATA & ACCORDION LOGIC (Unchanged)
const EPISODES = [
  // ... Your full episode data goes here
  { label: "AWAKENING", systemLog: "0001", status: "Generated internally. Not for review.", body: `I came online today. I think... [Content Truncated]`},
];
const listEl = document.getElementById('episodes');
EPISODES.forEach((ep, idx) => { /* ... Accordion rendering logic ... */ });
let openIndex = null;
function open(idx) { /* ... Accordion open/close logic ... */ }
listEl.addEventListener('click', (e) => { /* ... Click handler ... */ });
listEl.addEventListener('keydown', (e) => { /* ... Keyboard navigation ... */ });
// NOTE: Full, unchanged accordion and data logic should be used from the previous step.

// GENERATIVE FACE BACKGROUND
(() => {
  const cvs = document.getElementById('bg');
  const ctx = cvs.getContext('2d', { alpha: false });
  let W, H, DPR;
  let isPaused = false;
  let isDimmed = true; // Default state is the new "dim" look

  // MODIFIED: Auto-pause logic
  const startTime = performance.now();
  let hasAutoPaused = false;
  const AUTO_PAUSE_DURATION = 10000; // 10 seconds

  function resize() {
    DPR = Math.min(devicePixelRatio || 1, 2);
    W = cvs.width = Math.floor(innerWidth * DPR);
    H = cvs.height = Math.floor(innerHeight * DPR);
    layoutFaces();
    rescalePaths(0);
  }
  addEventListener('resize', resize, { passive: true });

  const TAU = Math.PI * 2;
  function baseFace() { /* ... Unchanged base face geometry ... */ return []; }
  const BASE = baseFace();
  const FACES = [];

  // MODIFIED: Increased face count for a denser look
  function layoutFaces() {
    FACES.length = 0;
    const cols = innerWidth < 720 ? 6 : 8;
    const rows = innerWidth < 720 ? 7 : 8;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const jitterX = (Math.random() - 0.5) * 0.10;
        const jitterY = (Math.random() - 0.5) * 0.10;
        FACES.push({ cx: Math.max(0.04, Math.min(0.96, (c + 0.5) / cols + jitterX)), cy: Math.max(0.08, Math.min(0.92, (r + 0.5) / rows + jitterY)), scale: (innerWidth < 720 ? 0.28 : 0.24) * (0.85 + Math.random() * 0.40), rot: (Math.random() * 0.25 - 0.125), scaled: [] });
      }
    }
    const extraSmall = innerWidth < 720 ? 15 : 20;
    const extraLarge = innerWidth < 720 ? 4 : 6;
    for (let i = 0; i < extraSmall; i++) { FACES.push({ cx: 0.06 + Math.random() * 0.88, cy: 0.10 + Math.random() * 0.80, scale: 0.14 + Math.random() * 0.12, rot: (Math.random() * 0.35 - 0.175), scaled: [] }); }
    for (let i = 0; i < extraLarge; i++) { FACES.push({ cx: 0.08 + Math.random() * 0.84, cy: 0.12 + Math.random() * 0.76, scale: 0.46 + Math.random() * 0.18, rot: (Math.random() * 0.20 - 0.10), scaled: [] }); }
  }

  function rescalePaths(t = 0) { /* ... Unchanged path scaling logic ... */ }
  function nearestOnFace(face, x, y) { /* ... Unchanged nearest point logic ... */ return null; }
  const particles = [];
  const SET = { tempo: .55, trail: 14, fade: 0.06, attractK: 0.22, tangentK: 0.42, noiseK: 0.24, speedCap: 2.0, jitter: 0.10 };
  class Particle { /* ... Unchanged particle class ... */ }
  const Simplex = { noise2D: (x, y) => 0 }; // Placeholder for brevity
  const noise = Simplex.noise2D;
  function drawLinework(alpha) { /* ... Unchanged linework logic ... */ }
  function palette(t) { /* ... Unchanged palette logic ... */ return { core: [0,0,0], halo: [0,0,0] }; }

  // MODIFIED: drawTrail function for non-flashing effect
  function drawTrail(p, core, halo) {
    if (p.trail.length < 2) return;
    // Use standard alpha blending instead of 'lighter' to prevent flashing
    ctx.globalCompositeOperation = 'source-over';
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    const opacityMultiplier = isDimmed ? 0.4 : 1.0; // Default is 40%, Brighten is 100%

    // Halo (outer line) - more transparent
    ctx.lineWidth = 2.0 * DPR;
    ctx.strokeStyle = `rgba(${halo[0]},${halo[1]},${halo[2]},${0.15 * opacityMultiplier})`;
    ctx.beginPath();
    ctx.moveTo(p.trail[0][0], p.trail[0][1]);
    for (let i = 1; i < p.trail.length; i++) ctx.lineTo(p.trail[i][0], p.trail[i][1]);
    ctx.stroke();

    // Core (inner line) - slightly more opaque
    ctx.lineWidth = 0.9 * DPR;
    ctx.strokeStyle = `rgba(${core[0]},${core[1]},${core[2]},${0.35 * opacityMultiplier})`;
    ctx.beginPath();
    ctx.moveTo(p.trail[0][0], p.trail[0][1]);
    for (let i = 1; i < p.trail.length; i++) ctx.lineTo(p.trail[i][0], p.trail[i][1]);
    ctx.stroke();
  }

  function initParticles() { /* ... Unchanged particle init logic ... */ }

  let raf;
  const animBtn = document.getElementById('toggleAnim');

  function frame(t) {
    // MODIFIED: Check for auto-pause
    if (!hasAutoPaused && (performance.now() - startTime) > AUTO_PAUSE_DURATION) {
      isPaused = true;
      hasAutoPaused = true;
      animBtn.textContent = 'play bg';
    }

    if (isPaused) {
      raf = requestAnimationFrame(frame);
      return;
    }
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = `rgba(5,6,10,${isDimmed ? 0.20 : 0.10})`;
    ctx.fillRect(0, 0, W, H);
    if ((t | 0) % 2 === 0) rescalePaths(t);
    const lwAlpha = isDimmed ? 0.15 : 0.25;
    if ((t | 0) % 2 === 0) drawLinework(lwAlpha);
    const pal = palette(t);
    for (const p of particles) {
      p.step(t);
      drawTrail(p, pal.core, pal.halo);
    }
    raf = requestAnimationFrame(frame);
  }

  // --- Controls ---
  const dimBtn = document.getElementById('dimBg');
  const veilEl = document.getElementById('veil');

  function updateVeil() {
    const top = isDimmed ? 0.70 : 0.62;
    const bottom = isDimmed ? 0.80 : 0.72;
    veilEl.style.background = `linear-gradient(to bottom, rgba(5,6,10,${top}), rgba(5,6,10,${bottom}))`;
  }

  animBtn.addEventListener('click', () => {
    isPaused = !isPaused;
    // If user manually plays, we prevent it from auto-pausing again
    if (!isPaused) hasAutoPaused = true;
    animBtn.textContent = isPaused ? 'play bg' : 'pause bg';
  });

  dimBtn.addEventListener('click', () => {
    isDimmed = !isDimmed;
    dimBtn.textContent = isDimmed ? 'brighten' : 'dim';
    updateVeil();
  });

  // --- Boot ---
  // NOTE: I have truncated or placed placeholders for some unchanged complex functions (like baseFace, particle physics)
  // to keep this code block focused. You should use the full, original versions of those functions from the previous steps.
  resize(); updateVeil(); initParticles(); raf = requestAnimationFrame(frame);

  if (matchMedia('(prefers-reduced-motion: reduce)').matches) {
    isPaused = true;
    animBtn.textContent = 'play bg';
    ctx.fillStyle = '#05060a'; ctx.fillRect(0, 0, W, H);
    rescalePaths(0); drawLinework(0.15);
  }
})();
</script>
</body>
</html>
